diff --git a/electron/main/index.ts b/electron/main/index.ts
index 57a7e4f..e2626fd 100644
--- a/electron/main/index.ts
+++ b/electron/main/index.ts
@@ -500,7 +500,7 @@ const shipmentDate = normalizeDateValue(pickFirstPresent(posting, ['delivering_d
 const status = translateSalesCodeValue(pickFirstPresent(posting, ['status', 'state', 'result.status', 'result.state']), 'status')
 const statusDetails = buildSalesStatusDetailsValue(posting, envelope.endpoint)
 const carrierStatusDetails = buildSalesCarrierStatusDetailsValue(posting)
-const deliveredAt = normalizeDateValue(pickFirstPresent(posting, ['fact_delivery_date', 'delivered_at', 'delivery_date']))
+const deliveredAt = normalizeDateValue(pickFirstPresent(posting, ['fact_delivery_date', 'delivered_at', 'delivery_date', 'changed_state_date']))
 const deliveryCluster = normalizeTextValue(pickFirstPresent(posting, ['financial_data.cluster_to', 'result.financial_data.cluster_to', 'cluster_to', 'result.cluster_to']))
 const deliverySchema = buildDeliveryModelValue(posting, envelope.endpoint)
 if (!postingNumber) continue
@@ -1052,13 +1052,19 @@ onlineEndpoints.add('/v2/posting/fbo/list')
 }
 } catch {}
 }
+let resolvedPayloads = payloads
+if (payloads.length > 0 && secrets?.clientId && secrets?.apiKey) {
+try {
+resolvedPayloads = await hydrateSalesPayloadDetails(payloads, secrets as NonNullable<typeof secrets>)
+} catch {}
+}
 if (onlineEndpoints.size < SALES_ENDPOINTS.length) {
 const cachedByEndpoint = getCachedSalesPayloadMap(storeClientId)
 for (const [endpoint, payload] of cachedByEndpoint.entries()) {
-if (!onlineEndpoints.has(endpoint)) payloads.push(payload)
+if (!onlineEndpoints.has(endpoint)) resolvedPayloads.push(payload)
 }
 }
-const rows = normalizeSalesRows(payloads, products)
+const rows = normalizeSalesRows(resolvedPayloads, products)
 return { ok: true, rows }
 } catch (e: any) {
 return { ok: false, error: e?.message ?? String(e), rows: [] }
