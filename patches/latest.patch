diff --git a/electron/main/ozon.ts b/electron/main/ozon.ts
index e271975..b8db7b6 100644
--- a/electron/main/ozon.ts
+++ b/electron/main/ozon.ts
@@ -109,6 +109,22 @@ type ProductAttributesV3 = {
   attributes?: Attribute[]
 }
 
+type DescriptionTreeName = {
+  categoryName: string | null
+  typeName: string | null
+}
+
+type DescriptionTreeMaps = {
+  byDescriptionCategoryId: Map<number, DescriptionTreeName>
+  byTypeId: Map<number, DescriptionTreeName>
+}
+
+let descriptionTreeCache: {
+  clientId: string
+  loadedAt: number
+  maps: DescriptionTreeMaps
+} | null = null
+
 // ---------------- Helpers ----------------
 
 function chunk<T>(arr: T[], size: number) {
@@ -247,6 +263,85 @@ async function fetchAttributesMap(secrets: Secrets, productIds: number[]) {
   return map
 }
 
+function mergeDescriptionTreeName(prev: DescriptionTreeName | undefined, next: DescriptionTreeName): DescriptionTreeName {
+  const categoryName = prev?.categoryName ?? next.categoryName ?? null
+  const typeName = prev?.typeName ?? next.typeName ?? null
+  return { categoryName, typeName }
+}
+
+function asNodeList(x: any): any[] {
+  if (Array.isArray(x)) return x
+  if (Array.isArray(x?.result)) return x.result
+  if (Array.isArray(x?.data)) return x.data
+  if (Array.isArray(x?.items)) return x.items
+  return []
+}
+
+async function fetchDescriptionTreeMaps(secrets: Secrets): Promise<DescriptionTreeMaps> {
+  const cached = descriptionTreeCache
+  if (cached && cached.clientId === secrets.clientId && (Date.now() - cached.loadedAt) < 6 * 60 * 60 * 1000) {
+    return cached.maps
+  }
+
+  let json: any
+  try {
+    json = await ozonPost(secrets, '/v1/description-category/tree', { language: 'DEFAULT' })
+  } catch (e1) {
+    try {
+      json = await ozonPost(secrets, '/v1/description-category/tree', {})
+    } catch {
+      throw e1
+    }
+  }
+
+  const maps: DescriptionTreeMaps = {
+    byDescriptionCategoryId: new Map<number, DescriptionTreeName>(),
+    byTypeId: new Map<number, DescriptionTreeName>(),
+  }
+
+  const visit = (node: any, inheritedCategoryName: string | null = null) => {
+    if (!node || typeof node !== 'object') return
+
+    const categoryName = pickFirstString(
+      (node as any).category_name,
+      (node as any).categoryName,
+      inheritedCategoryName,
+    )
+    const typeName = pickFirstString((node as any).type_name, (node as any).typeName)
+    const nameObj: DescriptionTreeName = { categoryName, typeName }
+
+    const descriptionCategoryId = Number(
+      (node as any).description_category_id ??
+      (node as any).descriptionCategoryId ??
+      (node as any).category_id ??
+      (node as any).categoryId ?? 0,
+    )
+    if (descriptionCategoryId > 0) {
+      const prev = maps.byDescriptionCategoryId.get(descriptionCategoryId)
+      maps.byDescriptionCategoryId.set(descriptionCategoryId, mergeDescriptionTreeName(prev, nameObj))
+    }
+
+    const typeId = Number((node as any).type_id ?? (node as any).typeId ?? 0)
+    if (typeId > 0) {
+      const prev = maps.byTypeId.get(typeId)
+      maps.byTypeId.set(typeId, mergeDescriptionTreeName(prev, nameObj))
+    }
+
+    const children = asNodeList((node as any).children)
+    for (const child of children) visit(child, categoryName ?? inheritedCategoryName)
+  }
+
+  for (const root of asNodeList(json)) visit(root, null)
+
+  descriptionTreeCache = {
+    clientId: secrets.clientId,
+    loadedAt: Date.now(),
+    maps,
+  }
+
+  return maps
+}
+
 function pickFirstString(...vals: any[]): string | null {
   for (const v of vals) {
     if (typeof v === 'string' && v.trim()) return v.trim()
@@ -492,5 +587,23 @@ export async function ozonProductInfoList(secrets: Secrets, productIds: number[]
     // атрибуты не критичны — если упали, оставляем базовые поля
   }
 
+  try {
+    const treeMaps = await fetchDescriptionTreeMaps(secrets)
+    for (const p of out) {
+      const typeKey = Number(p.type ?? 0)
+      const categoryKey = Number(p.category ?? 0)
+
+      const names = (typeKey > 0 ? treeMaps.byDescriptionCategoryId.get(typeKey) : undefined)
+        ?? (typeKey > 0 ? treeMaps.byTypeId.get(typeKey) : undefined)
+        ?? (categoryKey > 0 ? treeMaps.byDescriptionCategoryId.get(categoryKey) : undefined)
+        ?? (categoryKey > 0 ? treeMaps.byTypeId.get(categoryKey) : undefined)
+
+      const displayCategory = names?.typeName ?? names?.categoryName ?? null
+      if (displayCategory) p.category = displayCategory
+    }
+  } catch {
+    // дерево категорий не критично — оставляем текущее значение (id или null)
+  }
+
   return out
 }
