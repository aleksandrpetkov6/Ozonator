--- a/tests/e2e/human-smoke.spec.ts
+++ b/tests/e2e/human-smoke.spec.ts
@@ -1,7 +1,8 @@
 import { test, expect, Page, Locator } from '@playwright/test';
 import * as fs from 'node:fs';
+import * as http from 'node:http';
 import * as path from 'node:path';
-import { pathToFileURL } from 'node:url';
+import { fileURLToPath, pathToFileURL } from 'node:url';
 
 const NON_DESTRUCTIVE_BUTTON_BLACKLIST = /(удал|delete|remove|reset|сброс|drop|clear all|очист|logout|выйти|exit|close app|quit)/i;
 
@@ -27,6 +28,243 @@
 }
 
 type UiEntry = { target: string; mode: 'url' | 'file'; checked: string[] };
+
+
+type LocalStaticServer = {
+  url: string;
+  rootDir: string;
+  close: () => Promise<void>;
+};
+
+function contentTypeByPath(filePath: string): string {
+  const ext = path.extname(filePath).toLowerCase();
+  switch (ext) {
+    case '.html': return 'text/html; charset=utf-8';
+    case '.js':
+    case '.mjs': return 'application/javascript; charset=utf-8';
+    case '.css': return 'text/css; charset=utf-8';
+    case '.json': return 'application/json; charset=utf-8';
+    case '.svg': return 'image/svg+xml';
+    case '.png': return 'image/png';
+    case '.jpg':
+    case '.jpeg': return 'image/jpeg';
+    case '.ico': return 'image/x-icon';
+    case '.woff': return 'font/woff';
+    case '.woff2': return 'font/woff2';
+    case '.ttf': return 'font/ttf';
+    default: return 'application/octet-stream';
+  }
+}
+
+async function startLocalStaticServer(indexHtmlPath: string): Promise<LocalStaticServer> {
+  const rootDir = path.dirname(indexHtmlPath);
+  const indexFile = path.resolve(indexHtmlPath);
+
+  const server = http.createServer((req, res) => {
+    try {
+      const reqUrl = new URL(req.url || '/', 'http://127.0.0.1');
+      let pathname = decodeURIComponent(reqUrl.pathname || '/');
+      if (!pathname || pathname === '/') pathname = '/index.html';
+
+      const candidate = path.resolve(rootDir, `.${pathname}`);
+      const rel = path.relative(rootDir, candidate);
+
+      let fileToServe = candidate;
+      if (rel.startsWith('..') || path.isAbsolute(rel)) {
+        res.statusCode = 403;
+        res.end('Forbidden');
+        return;
+      }
+
+      if (!fs.existsSync(fileToServe) || !fs.statSync(fileToServe).isFile()) {
+        fileToServe = indexFile; // SPA fallback
+      }
+
+      const body = fs.readFileSync(fileToServe);
+      res.setHeader('Content-Type', contentTypeByPath(fileToServe));
+      res.setHeader('Cache-Control', 'no-store');
+      res.statusCode = 200;
+      res.end(body);
+    } catch (err) {
+      res.statusCode = 500;
+      res.end(String(err));
+    }
+  });
+
+  await new Promise<void>((resolve, reject) => {
+    server.once('error', reject);
+    server.listen(0, '127.0.0.1', () => resolve());
+  });
+
+  const addr = server.address();
+  if (!addr || typeof addr === 'string') {
+    throw new Error('Не удалось поднять локальный static server для built UI');
+  }
+
+  return {
+    url: `http://127.0.0.1:${addr.port}/`,
+    rootDir,
+    close: () => new Promise<void>((resolve) => server.close(() => resolve())),
+  };
+}
+
+async function installE2EWindowApiStub(page: Page): Promise<void> {
+  await page.addInitScript(() => {
+    const w = window as typeof window & { api?: unknown; __ozonatorE2EStubInstalled?: boolean };
+    if (w.__ozonatorE2EStubInstalled) return;
+    w.__ozonatorE2EStubInstalled = true;
+
+    const products = Array.from({ length: 240 }, (_, i) => ({
+      id: i + 1,
+      product_id: i + 1,
+      sku: 100000 + i,
+      offer_id: `TEST_${String(i + 1).padStart(4, '0')}`,
+      name: `Тестовый товар ${i + 1}`,
+      category: `Категория ${1 + (i % 12)}`,
+      brand: `Бренд ${1 + (i % 7)}`,
+      type: 'Тест',
+      visible: true,
+      is_visible: true,
+      price: 100 + i,
+      stock: 50 + (i % 20),
+      updated_at: new Date().toISOString(),
+    }));
+
+    const productsArray = products.slice() as typeof products & Record<string, unknown>;
+    productsArray.items = products;
+    productsArray.rows = products;
+    productsArray.data = products;
+    productsArray.products = products;
+    productsArray.total = products.length;
+    productsArray.count = products.length;
+
+    const logs = Array.from({ length: 60 }, (_, i) => ({
+      id: i + 1,
+      action: i % 2 === 0 ? 'sync_products' : 'check_auth',
+      status: 'success',
+      started_at: new Date(Date.now() - (i + 1) * 60_000).toISOString(),
+      finished_at: new Date(Date.now() - i * 60_000).toISOString(),
+      message: `E2E log ${i + 1}`,
+      error: null,
+      rows_count: (i + 1) * 3,
+    }));
+
+    const settings = {
+      clientId: '',
+      client_id: '',
+      apiKey: '',
+      api_key: '',
+      storeName: 'E2E Demo Store',
+      store_name: 'E2E Demo Store',
+    };
+
+    const mockByPath = (segments: string[]) => {
+      const key = segments.join('.').toLowerCase();
+      const last = (segments[segments.length - 1] || '').toLowerCase();
+
+      if (/\.subscribe$|\.unsubscribe$|\.off$/.test(key) || /^on[A-Z]/.test(segments[segments.length - 1] || '')) {
+        return () => {};
+      }
+
+      if (/net.*check|check.*net|netcheck/.test(key)) {
+        return { online: false, isOnline: false };
+      }
+
+      if (/testauth|checkauth/.test(key)) {
+        return { ok: true, storeName: settings.storeName, store_name: settings.store_name };
+      }
+
+      if (/sync.*product|product.*sync/.test(key)) {
+        return { ok: true, count: products.length, synced: products.length };
+      }
+
+      if (/(get|list|read|load).*product|products?$/.test(key)) {
+        return productsArray;
+      }
+
+      if (/(get|list|read|load).*log|logs?$/.test(key)) {
+        return logs;
+      }
+
+      if (/setting|secret|config/.test(key)) {
+        return settings;
+      }
+
+      if (/version|build/.test(key)) {
+        return { version: 'e2e-stub', build: 'e2e-stub' };
+      }
+
+      return null;
+    };
+
+    const makeNode = (segments: string[]): any => new Proxy(function () {}, {
+      get(_target, prop) {
+        if (prop === 'then') return undefined;
+        if (prop === Symbol.toStringTag) return 'Function';
+        if (prop === 'toJSON') return () => ({ stub: segments.join('.') });
+        return makeNode([...segments, String(prop)]);
+      },
+      apply() {
+        return mockByPath(segments);
+      },
+    });
+
+    if (!('api' in w) || !w.api) {
+      Object.defineProperty(w, 'api', {
+        configurable: true,
+        writable: true,
+        value: makeNode(['api']),
+      });
+    }
+  });
+}
+
+async function waitForUiReady(page: Page, timeoutMs = 25_000): Promise<void> {
+  const started = Date.now();
+  let lastSnapshot = 'no-snapshot';
+
+  while (Date.now() - started < timeoutMs) {
+    const snapshot = await page.evaluate(() => {
+      const body = document.body;
+      const root = document.querySelector('#root');
+      if (!body) return { ok: false, reason: 'no-body' };
+
+      const cs = window.getComputedStyle(body);
+      const hidden =
+        cs.display === 'none' ||
+        cs.visibility === 'hidden' ||
+        Number.parseFloat(cs.opacity || '1') === 0;
+
+      const visibleNode = Array.from(document.querySelectorAll<HTMLElement>('body *')).some((el) => {
+        const s = window.getComputedStyle(el);
+        const r = el.getBoundingClientRect();
+        return s.display !== 'none' && s.visibility !== 'hidden' && r.width > 2 && r.height > 2;
+      });
+
+      const textLen = (body.innerText || '').trim().length;
+      const rootChildren = root?.children?.length ?? 0;
+
+      return {
+        ok: !hidden && (visibleNode || textLen > 0 || rootChildren > 0),
+        hidden,
+        textLen,
+        rootChildren,
+        bodyChildren: body.children.length,
+        bodyRect: { w: body.getBoundingClientRect().width, h: body.getBoundingClientRect().height },
+        hasWindowApi: !!(window as typeof window & { api?: unknown }).api,
+        title: document.title,
+      };
+    }).catch((e) => ({ ok: false, reason: String(e) }));
+
+    lastSnapshot = JSON.stringify(snapshot);
+
+    if ((snapshot as { ok?: boolean }).ok) return;
+    await page.waitForTimeout(200);
+  }
+
+  throw new Error(`UI не перешёл в готовое состояние за ${timeoutMs}мс. snapshot=${lastSnapshot}`);
+}
+
 
 function findBuiltIndexHtml(): { filePath: string; checked: string[] } | null {
   const cwd = process.cwd();
@@ -219,6 +457,47 @@
   }, move ?? {});
 }
 
+
+async function tryDragVerticalScrollbarThumb(page: Page, debug: { notes: string[] }): Promise<void> {
+  const thumb = await firstVisible(
+    page.locator([
+      '[role="scrollbar"][aria-orientation="vertical"]',
+      '.simplebar-scrollbar',
+      '.os-scrollbar-vertical .os-scrollbar-handle',
+      '.ag-body-vertical-scroll',
+      '.ag-body-vertical-scroll-viewport',
+    ].join(',')),
+    12,
+  );
+
+  if (!thumb) {
+    debug.notes.push('thumb-drag:not-found');
+    return;
+  }
+
+  const box = await thumb.boundingBox().catch(() => null);
+  if (!box) {
+    debug.notes.push('thumb-drag:no-bbox');
+    return;
+  }
+
+  const x = box.x + Math.max(2, Math.min(box.width - 2, box.width / 2));
+  const yTop = box.y + Math.max(2, Math.min(box.height - 2, box.height * 0.2));
+  const yBottom = box.y + Math.max(2, Math.min(box.height - 2, box.height * 0.85));
+
+  try {
+    await page.mouse.move(x, yTop);
+    await page.mouse.down();
+    await page.mouse.move(x, yBottom, { steps: 10 });
+    await page.mouse.move(x, yTop, { steps: 10 });
+    await page.mouse.up();
+    debug.notes.push('thumb-drag:attempted');
+  } catch (err) {
+    debug.notes.push(`thumb-drag:error:${String(err)}`);
+    await page.mouse.up().catch(() => {});
+  }
+}
+
 type ScrollDebug = {
   base: ScrollProbe;
   jumps: number[];
@@ -286,6 +565,8 @@
       await page.waitForTimeout(60);
     }
   }
+
+  await tryDragVerticalScrollbarThumb(page, debug);
 
   const wheelBursts = [2200, -1800, 2600, -2400, 3200, -3000];
   for (const delta of wheelBursts) {
@@ -339,16 +620,27 @@
 test('human smoke: UI usage (aggressive scrollbar drag/wheel, columns, logs, category)', async ({ page }) => {
   const debugOutPath = path.resolve('test-results', 'human-scroll-debug.json');
   const traceOutPath = path.resolve('test-results', 'human-scroll-trace.zip');
+  let localServer: LocalStaticServer | null = null;
+  let manualTraceStarted = false;
 
   try {
     const ui = await resolveUiEntry();
-    const baseUrl = ui.target;
+    let baseUrl = ui.target;
+    if (ui.mode === 'file') {
+      localServer = await startLocalStaticServer(fileURLToPath(ui.target));
+      baseUrl = localServer.url;
+    }
 
     const pageErrors: string[] = [];
     const consoleErrors: string[] = [];
   fs.mkdirSync(path.dirname(debugOutPath), { recursive: true });
 
-  await page.context().tracing.start({ screenshots: true, snapshots: true, sources: true }).catch(() => {});
+  try {
+    await page.context().tracing.start({ screenshots: true, snapshots: true, sources: true });
+    manualTraceStarted = true;
+  } catch (err) {
+    test.info().annotations.push({ type: 'trace-start', description: `skip:${String(err)}` });
+  }
 
   page.on('pageerror', (err) => {
     pageErrors.push(String(err?.message || err));
@@ -363,10 +655,13 @@
     }
   });
 
-  await page.goto(baseUrl, { waitUntil: 'domcontentloaded', timeout: 30_000 });
-  await page.waitForLoadState('networkidle', { timeout: 10_000 }).catch(() => {});
-
-  await expect(page.locator('body')).toBeVisible();
+  await installE2EWindowApiStub(page);
+
+  await test.step('open-ui', async () => {
+    await page.goto(baseUrl, { waitUntil: 'domcontentloaded', timeout: 30_000 });
+    await page.waitForLoadState('networkidle', { timeout: 10_000 }).catch(() => {});
+    await waitForUiReady(page);
+  });
 
   // Переходы по типичным вкладкам/экранам + проверки, что экраны реально открылись
   const productsOpen1 = await clickByTexts(page, [/товар/i, /products?/i, /каталог/i], 2);
@@ -461,8 +756,11 @@
     window.scrollTo({ top: 0 });
   });
 
-  const verticalDebug = await assertAggressiveVerticalScrollNoBlank(page);
-  await assertHorizontalScrollAlwaysReachable(page);
+  const verticalDebug = await test.step('aggressive-scroll-check', async () => {
+    const dbg = await assertAggressiveVerticalScrollNoBlank(page);
+    await assertHorizontalScrollAlwaysReachable(page);
+    return dbg;
+  });
 
   // Проверка, что UI живой и не пустой после действий/скролла
   const visibleRows = await page.locator('table tr, [role="row"], .ag-row').count().catch(() => 0);
@@ -471,7 +769,11 @@
 
   const finalProbe = await probePrimaryScrollable(page);
   const debugPayload = {
-    ui,
+    ui: { ...ui, target: baseUrl },
+    runtime: {
+      manualTraceStarted,
+      localServerRoot: localServer?.rootDir ?? null,
+    },
     verticalDebug,
     finalProbe,
     pageErrors,
@@ -501,12 +803,18 @@
     description: consoleErrors.slice(0, 10).join(' | ') || 'none',
   });
   } finally {
-    await page.context().tracing.stop({ path: traceOutPath }).catch(() => {});
-    if (fs.existsSync(traceOutPath)) {
-      await test.info().attach('human-scroll-trace', {
-        path: traceOutPath,
-        contentType: 'application/zip',
-      });
+    if (manualTraceStarted) {
+      await page.context().tracing.stop({ path: traceOutPath }).catch(() => {});
+      if (fs.existsSync(traceOutPath)) {
+        await test.info().attach('human-scroll-trace', {
+          path: traceOutPath,
+          contentType: 'application/zip',
+        });
+      }
+    }
+
+    if (localServer) {
+      await localServer.close().catch(() => {});
     }
   }
 });
