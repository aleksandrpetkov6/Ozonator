diff --git a/src/renderer/src/ui/pages/ProductsPage.tsx b/src/renderer/src/ui/pages/ProductsPage.tsx
--- a/src/renderer/src/ui/pages/ProductsPage.tsx
+++ b/src/renderer/src/ui/pages/ProductsPage.tsx
@@ -1 +1 @@
-import React, { useEffect, useMemo, useRef, useState } from 'react' type ColId = | 'offer_id' | 'product_id' | 'name' | 'brand' | 'category' | 'type' | 'sku' | 'barcode' | 'created_at' | 'archived' type Col = { id: ColId; title: string; w: number; visible: boolean } const DEFAULT_COLS: Col[] = [ { id: 'offer_id', title: 'Артикул', w: 180, visible: true }, { id: 'name', title: 'Название', w: 320, visible: true }, { id: 'brand', title: 'Бренд', w: 160, visible: true }, { id: 'category', title: 'Категория', w: 220, visible: true }, { id: 'type', title: 'Тип', w: 180, visible: true }, { id: 'sku', title: 'SKU', w: 130, visible: true }, { id: 'barcode', title: 'Barcode', w: 160, visible: false }, { id: 'product_id', title: 'Product ID', w: 120, visible: false }, { id: 'created_at', title: 'Создан', w: 170, visible: true }, { id: 'archived', title: 'Архив', w: 90, visible: false }, ] const COL_ID_SET = new Set(DEFAULT_COLS.map((c) => c.id)) const isColId = (v: any): v is ColId => typeof v === 'string' && COL_ID_SET.has(v as ColId) function fmt(dtIso: string | null): string { if (!dtIso) return '' const d = new Date(dtIso) if (Number.isNaN(d.getTime())) return dtIso const pad = (n: number) => String(n).padStart(2, '0') return `${pad(d.getDate())}.${pad(d.getMonth() + 1)}.${String(d.getFullYear()).slice(-2)} ${pad(d.getHours())}:${pad( d.getMinutes() )}:${pad(d.getSeconds())}` } const ROW_H = 34 const OVERSCAN = 12 export default function ProductsPage() { const [all, setAll] = useState([]) const [q, setQ] = useState('') const [cols, setCols] = useState(() => { try { const saved = localStorage.getItem('ozonator-cols-v2') if (saved) { const parsed = JSON.parse(saved) if (Array.isArray(parsed)) { const byId = new Map() const order: ColId[] = [] for (const raw of parsed) { const id = raw?.id if (!isColId(id)) continue byId.set(id, raw) if (!order.includes(id)) order.push(id) } const out: Col[] = [] const used = new Set() for (const id of order) { const def = DEFAULT_COLS.find((c) => c.id === id) if (!def) continue const raw = byId.get(id) const w = typeof raw?.w === 'number' && Number.isFinite(raw.w) ? Math.max(60, Math.round(raw.w)) : def.w const visible = typeof raw?.visible === 'boolean' ? raw.visible : def.visible out.push({ ...def, w, visible }) used.add(id) } for (const def of DEFAULT_COLS) { if (!used.has(def.id)) out.push(def) } return out } } } catch {} return DEFAULT_COLS }) const [scrollTop, setScrollTop] = useState(0) const [viewportH, setViewportH] = useState(400) const wrapRef = useRef(null) // resize const [resizeGuideX, setResizeGuideX] = useState(null) const resizeRef = useRef<{ id: ColId; startX: number; startW: number; raf?: number } | null>(null) // drag reorder const [dropGuide, setDropGuide] = useState<{ id: ColId; side: 'left' | 'right'; x: number } | null>(null) const dragRef = useRef<{ draggingId: ColId; raf?: number; lastKey?: string } | null>(null) const visibleCols = useMemo(() => cols.filter((c) => c.visible), [cols]) const hiddenCols = useMemo(() => cols.filter((c) => !c.visible), [cols]) const gridTemplate = useMemo(() => visibleCols.map((c) => `${c.w}px`).join(' '), [visibleCols]) const tableW = useMemo(() => visibleCols.reduce((s, c) => s + c.w, 0), [visibleCols]) useEffect(() => { try { localStorage.setItem('ozonator-cols-v2', JSON.stringify(cols)) } catch {} }, [cols]) const load = async () => { const rows = await window.api.getProducts() setAll(Array.isArray(rows) ? rows : []) } useEffect(() => { load() }, []) useEffect(() => { const el = wrapRef.current if (!el) return const onScroll = () => { setScrollTop(el.scrollTop) } onScroll() el.addEventListener('scroll', onScroll, { passive: true }) const ro = new ResizeObserver(() => { setViewportH(el.clientHeight) }) ro.observe(el) return () => { el.removeEventListener('scroll', onScroll as any) ro.disconnect() } }, []) const filtered = useMemo(() => { const qq = q.trim().toLowerCase() if (!qq) return all return all.filter((r) => { const hay = [ r.offer_id, r.name, r.brand, r.category, r.type, r.sku, r.barcode, String(r.product_id ?? ''), ] .filter(Boolean) .join(' ') .toLowerCase() return hay.includes(qq) }) }, [all, q]) const totalH = filtered.length * ROW_H const start = Math.max(0, Math.floor(scrollTop / ROW_H) - OVERSCAN) const end = Math.min(filtered.length, Math.ceil((scrollTop + viewportH) / ROW_H) + OVERSCAN) const slice = filtered.slice(start, end) // ===== column actions ===== const hideCol = (id: ColId) => setCols((prev) => prev.map((c) => (c.id === id ? { ...c, visible: false } : c))) const showCol = (id: ColId) => setCols((prev) => prev.map((c) => (c.id === id ? { ...c, visible: true } : c))) // ===== resize ===== const onResizeDown = (id: ColId, e: React.MouseEvent) => { e.preventDefault() e.stopPropagation() const col = cols.find((c) => c.id === id) if (!col) return resizeRef.current = { id, startX: e.clientX, startW: col.w } const onMove = (ev: MouseEvent) => { const r = resizeRef.current if (!r) return const dx = ev.clientX - r.startX const w = Math.max(60, r.startW + dx) // guide line (вниз по всей таблице) const wrap = wrapRef.current if (wrap) { const rect = wrap.getBoundingClientRect() const x = Math.min(Math.max(0, (r.startW + dx) + visibleColsBeforeWidth(r.id, cols) - wrap.scrollLeft), tableW) setResizeGuideX(rect.left + x) } // throttled width update if (r.raf) cancelAnimationFrame(r.raf) r.raf = requestAnimationFrame(() => { setCols((prev) => prev.map((c) => (c.id === id ? { ...c, w } : c))) }) } const onUp = () => { resizeRef.current = null setResizeGuideX(null) window.removeEventListener('mousemove', onMove) window.removeEventListener('mouseup', onUp) } window.addEventListener('mousemove', onMove) window.addEventListener('mouseup', onUp) } // ===== drag reorder ===== const onDragStart = (id: ColId) => { dragRef.current = { draggingId: id } } const onDragEnd = () => { dragRef.current = null setDropGuide(null) } const onDragOverHeader = (targetId: ColId, e: React.DragEvent) => { e.preventDefault() const drag = dragRef.current if (!drag) return if (drag.draggingId === targetId) return const rect = (e.currentTarget as HTMLDivElement).getBoundingClientRect() const x = e.clientX - rect.left const side: 'left' | 'right' = x < rect.width / 2 ? 'left' : 'right' // анти-джиттер: обновляем только если реально изменилось (и чуть гистерезис) const key = `${targetId}:${side}` if (drag.lastKey === key) return drag.lastKey = key if (drag.raf) cancelAnimationFrame(drag.raf) drag.raf = requestAnimationFrame(() => { // x-position for guide within whole table const targetLeft = visibleColsBeforeWidth(targetId, cols) const guideX = side === 'left' ? targetLeft : targetLeft + (cols.find((c) => c.id === targetId)?.w ?? 0) setDropGuide({ id: targetId, side, x: guideX }) }) } const onDropHeader = (targetId: ColId, e: React.DragEvent) => { e.preventDefault() const drag = dragRef.current if (!drag) return const fromId = drag.draggingId if (fromId === targetId) return const rect = (e.currentTarget as HTMLDivElement).getBoundingClientRect() const x = e.clientX - rect.left const side: 'left' | 'right' = x < rect.width / 2 ? 'left' : 'right' setCols((prev) => reorder(prev, fromId, targetId, side)) setDropGuide(null) } // ===== render ===== return (
+import React, { useEffect, useMemo, useRef, useState } from 'react' type ColId = | 'offer_id' | 'product_id' | 'name' | 'brand' | 'category' | 'type' | 'sku' | 'barcode' | 'created_at' | 'archived' type Col = { id: ColId; title: string; w: number; visible: boolean } const DEFAULT_COLS: Col[] = [ { id: 'offer_id', title: 'Артикул', w: 180, visible: true }, { id: 'name', title: 'Название', w: 320, visible: true }, { id: 'brand', title: 'Бренд', w: 160, visible: true }, { id: 'category', title: 'Категория', w: 220, visible: true }, { id: 'type', title: 'Тип', w: 180, visible: true }, { id: 'sku', title: 'SKU', w: 130, visible: true }, { id: 'barcode', title: 'Barcode', w: 160, visible: false }, { id: 'product_id', title: 'Product ID', w: 120, visible: false }, { id: 'created_at', title: 'Создан', w: 170, visible: true }, { id: 'archived', title: 'Архив', w: 90, visible: false }, ] const COL_ID_SET = new Set(DEFAULT_COLS.map((c) => c.id)) const isColId = (v: any): v is ColId => typeof v === 'string' && COL_ID_SET.has(v as ColId) function fmt(dtIso: string | null): string { if (!dtIso) return '' const d = new Date(dtIso) if (Number.isNaN(d.getTime())) return dtIso const pad = (n: number) => String(n).padStart(2, '0') return `${pad(d.getDate())}.${pad(d.getMonth() + 1)}.${String(d.getFullYear()).slice(-2)} ${pad(d.getHours())}:${pad( d.getMinutes() )}:${pad(d.getSeconds())}` } const ROW_H = 34 const OVERSCAN = 12 export default function ProductsPage() { const [all, setAll] = useState([]) const [q, setQ] = useState('') const [cols, setCols] = useState(() => { try { const saved = localStorage.getItem('ozonator-cols-v2') if (saved) { const parsed = JSON.parse(saved) if (Array.isArray(parsed)) { const byId = new Map() const order: ColId[] = [] for (const raw of parsed) { const id = raw?.id if (!isColId(id)) continue byId.set(id, raw) if (!order.includes(id)) order.push(id) } const out: Col[] = [] const used = new Set() for (const id of order) { const def = DEFAULT_COLS.find((c) => c.id === id) if (!def) continue const raw = byId.get(id) const w = typeof raw?.w === 'number' && Number.isFinite(raw.w) ? Math.max(60, Math.round(raw.w)) : def.w const visible = typeof raw?.visible === 'boolean' ? raw.visible : def.visible out.push({ ...def, w, visible }) used.add(id) } for (const def of DEFAULT_COLS) { if (!used.has(def.id)) out.push(def) } return out } } } catch {} return DEFAULT_COLS }) const [scrollTop, setScrollTop] = useState(0) const [viewportH, setViewportH] = useState(400) const wrapRef = useRef(null) // resize const [resizeGuideX, setResizeGuideX] = useState(null) const resizeRef = useRef<{ id: ColId; startX: number; startW: number; raf?: number } | null>(null) // drag reorder const [dropGuide, setDropGuide] = useState<{ id: ColId; side: 'left' | 'right'; x: number } | null>(null) const dragRef = useRef<{ draggingId: ColId; raf?: number; lastKey?: string } | null>(null) const visibleCols = useMemo(() => cols.filter((c) => c.visible), [cols]) const hiddenCols = useMemo(() => cols.filter((c) => !c.visible), [cols]) const gridTemplate = useMemo(() => visibleCols.map((c) => `${c.w}px`).join(' '), [visibleCols]) const tableW = useMemo(() => visibleCols.reduce((s, c) => s + c.w, 0), [visibleCols]) useEffect(() => { try { localStorage.setItem('ozonator-cols-v2', JSON.stringify(cols)) } catch {} }, [cols]) const load = async () => { const rows = await window.api.getProducts() setAll(Array.isArray(rows) ? rows : []) } useEffect(() => { load() }, []) useEffect(() => { const el = wrapRef.current as any as HTMLDivElement | null if (!el) return let syncing = false const bar = document.createElement('div') bar.className = 'hScrollSticky' const inner = document.createElement('div') inner.className = 'hScrollStickyInner' bar.appendChild(inner) const parent = el.parentElement if (parent) parent.insertBefore(bar, el.nextSibling) const refresh = () => { const w = Math.max(tableW, el.scrollWidth) inner.style.width = `${w}px` const need = w > el.clientWidth + 1 bar.style.display = need ? 'block' : 'none' if (need && !syncing) { syncing = true bar.scrollLeft = el.scrollLeft syncing = false } setViewportH(el.clientHeight) } const onScroll = () => { setScrollTop(el.scrollTop) if (!syncing) { syncing = true bar.scrollLeft = el.scrollLeft syncing = false } } const onBarScroll = () => { if (syncing) return syncing = true el.scrollLeft = bar.scrollLeft syncing = false } onScroll() refresh() el.addEventListener('scroll', onScroll, { passive: true }) bar.addEventListener('scroll', onBarScroll, { passive: true }) const ro = new ResizeObserver(refresh) ro.observe(el) return () => { el.removeEventListener('scroll', onScroll as any) bar.removeEventListener('scroll', onBarScroll as any) ro.disconnect() bar.remove() } }, [tableW]) const filtered = useMemo(() => { const qq = q.trim().toLowerCase() if (!qq) return all return all.filter((r) => { const hay = [ r.offer_id, r.name, r.brand, r.category, r.type, r.sku, r.barcode, String(r.product_id ?? ''), ] .filter(Boolean) .join(' ') .toLowerCase() return hay.includes(qq) }) }, [all, q]) const totalH = filtered.length * ROW_H const start = Math.max(0, Math.floor(scrollTop / ROW_H) - OVERSCAN) const end = Math.min(filtered.length, Math.ceil((scrollTop + viewportH) / ROW_H) + OVERSCAN) const slice = filtered.slice(start, end) // ===== column actions ===== const hideCol = (id: ColId) => setCols((prev) => prev.map((c) => (c.id === id ? { ...c, visible: false } : c))) const showCol = (id: ColId) => setCols((prev) => prev.map((c) => (c.id === id ? { ...c, visible: true } : c))) // ===== resize ===== const onResizeDown = (id: ColId, e: React.MouseEvent) => { e.preventDefault() e.stopPropagation() const col = cols.find((c) => c.id === id) if (!col) return resizeRef.current = { id, startX: e.clientX, startW: col.w } const onMove = (ev: MouseEvent) => { const r = resizeRef.current if (!r) return const dx = ev.clientX - r.startX const w = Math.max(60, r.startW + dx) // guide line (вниз по всей таблице) const wrap = wrapRef.current if (wrap) { const rect = wrap.getBoundingClientRect() const x = Math.min(Math.max(0, (r.startW + dx) + visibleColsBeforeWidth(r.id, cols) - wrap.scrollLeft), tableW) setResizeGuideX(rect.left + x) } // throttled width update if (r.raf) cancelAnimationFrame(r.raf) r.raf = requestAnimationFrame(() => { setCols((prev) => prev.map((c) => (c.id === id ? { ...c, w } : c))) }) } const onUp = () => { resizeRef.current = null setResizeGuideX(null) window.removeEventListener('mousemove', onMove) window.removeEventListener('mouseup', onUp) } window.addEventListener('mousemove', onMove) window.addEventListener('mouseup', onUp) } // ===== drag reorder ===== const onDragStart = (id: ColId) => { dragRef.current = { draggingId: id } } const onDragEnd = () => { dragRef.current = null setDropGuide(null) } const onDragOverHeader = (targetId: ColId, e: React.DragEvent) => { e.preventDefault() const drag = dragRef.current if (!drag) return if (drag.draggingId === targetId) return const rect = (e.currentTarget as HTMLDivElement).getBoundingClientRect() const x = e.clientX - rect.left const side: 'left' | 'right' = x < rect.width / 2 ? 'left' : 'right' // анти-джиттер: обновляем только если реально изменилось (и чуть гистерезис) const key = `${targetId}:${side}` if (drag.lastKey === key) return drag.lastKey = key if (drag.raf) cancelAnimationFrame(drag.raf) drag.raf = requestAnimationFrame(() => { // x-position for guide within whole table const targetLeft = visibleColsBeforeWidth(targetId, cols) const guideX = side === 'left' ? targetLeft : targetLeft + (cols.find((c) => c.id === targetId)?.w ?? 0) setDropGuide({ id: targetId, side, x: guideX }) }) } const onDropHeader = (targetId: ColId, e: React.DragEvent) => { e.preventDefault() const drag = dragRef.current if (!drag) return const fromId = drag.draggingId if (fromId === targetId) return const rect = (e.currentTarget as HTMLDivElement).getBoundingClientRect() const x = e.clientX - rect.left const side: 'left' | 'right' = x < rect.width / 2 ? 'left' : 'right' setCols((prev) => reorder(prev, fromId, targetId, side)) setDropGuide(null) } // ===== render ===== return (

diff --git a/src/renderer/src/ui/styles.css b/src/renderer/src/ui/styles.css
--- a/src/renderer/src/ui/styles.css
+++ b/src/renderer/src/ui/styles.css
@@ -1 +1,5 @@
-/* ===== Base ===== */ html, body, #root { height: 100%; } body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #ffffff; color: #111827; } * { box-sizing: border-box; } a { color: inherit; } /* ===== Layout ===== */ .app { height: 100%; display: flex; flex-direction: column; } .header { height: 56px; display: flex; align-items: center; justify-content: space-between; padding: 0 12px; border-bottom: 1px solid #e5e7eb; background: #ffffff; } .brand { display: flex; align-items: baseline; gap: 10px; min-width: 280px; } .brandTitle { font-weight: 800; letter-spacing: 0.2px; } .brandStore { font-size: 12px; color: #6b7280; max-width: 520px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .headerBtns { display: flex; gap: 8px; align-items: center; } .iconBtn { height: 36px; min-width: 36px; padding: 0 10px; border: 1px solid #d1d5db; border-radius: 10px; background: #f3f4f6; /* единый фон как у "настройки" */ cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 8px; user-select: none; } .iconBtn:hover { background: #e5e7eb; } .iconBtn:active { transform: translateY(1px); } .iconBtnPrimary { border-color: #c7d2fe; background: #eef2ff; } .iconBtnPrimary:hover { background: #e0e7ff; } .main { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; } .page { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; padding: 12px; gap: 10px; } /* ===== Controls ===== */ .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; } .input { height: 34px; padding: 0 10px; border: 1px solid #d1d5db; border-radius: 10px; background: #fff; outline: none; } .input:focus { border-color: #a5b4fc; } .btn { height: 34px; padding: 0 12px; border: 1px solid #d1d5db; border-radius: 10px; background: #ffffff; cursor: pointer; } .btn:hover { background: #f9fafb; } .btn:active { transform: translateY(1px); } .badge { font-size: 12px; color: #374151; background: #f3f4f6; border: 1px solid #e5e7eb; border-radius: 999px; padding: 4px 10px; } /* ===== Table (virtualized grid) ===== */ .tableWrap { flex: 1 1 auto; min-height: 0; border: 1px solid #e5e7eb; border-radius: 12px; overflow: auto; position: relative; scrollbar-gutter: stable both-edges; background: #fff; } .tableInner { position: relative; min-width: 600px; } .headerRowSticky { position: sticky; top: 0; z-index: 5; background: #ffffff; border-bottom: 1px solid #e5e7eb; } .gridRow { display: grid; align-items: center; height: 34px; line-height: 34px; border-bottom: 1px solid #f3f4f6; } .headerCell { font-size: 12px; font-weight: 700; color: #374151; padding: 0 10px; position: relative; user-select: none; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .cell { font-size: 13px; padding: 0 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .rowAlt { background: #fcfcfd; } .resizeHandle { position: absolute; right: 0; top: 0; bottom: 0; width: 10px; cursor: col-resize; } .resizeGuide { position: absolute; top: 0; bottom: 0; width: 2px; background: #2563eb; opacity: 0.6; pointer-events: none; z-index: 10; } .dropGuide { position: absolute; top: 0; bottom: 0; width: 3px; background: #2563eb; opacity: 0.55; pointer-events: none; z-index: 9; } /* ===== Hidden columns bar (compact) ===== */ .hiddenBar { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; } .hiddenChip { height: 24px; padding: 0 8px; border: 1px dashed #d1d5db; border-radius: 999px; background: #ffffff; font-size: 12px; display: inline-flex; align-items: center; gap: 6px; } .hiddenChipBtn { border: none; background: #f3f4f6; border-radius: 999px; width: 18px; height: 18px; cursor: pointer; line-height: 18px; text-align: center; } .hiddenChipBtn:hover { background: #e5e7eb; } /* ===== Logs list ===== */ .logList { display: flex; flex-direction: column; gap: 8px; } .logItem { border: 1px solid #e5e7eb; border-radius: 12px; padding: 10px 12px; background: #fff; } .logTop { display: flex; justify-content: space-between; gap: 10px; align-items: baseline; } .logType { font-weight: 700; } .logMeta { color: #6b7280; font-size: 12px; } .logMsg { margin-top: 6px; color: #374151; font-size: 13px; white-space: pre-wrap; }
+/* ===== Base ===== */ html, body, #root { height: 100%; } body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #ffffff; color: #111827; } * { box-sizing: border-box; } a { color: inherit; } /* ===== Layout ===== */ .app { height: 100%; display: flex; flex-direction: column; } .header { height: 56px; display: flex; align-items: center; justify-content: space-between; padding: 0 12px; border-bottom: 1px solid #e5e7eb; background: #ffffff; } .brand { display: flex; align-items: baseline; gap: 10px; min-width: 280px; } .brandTitle { font-weight: 800; letter-spacing: 0.2px; } .brandStore { font-size: 12px; color: #6b7280; max-width: 520px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .headerBtns { display: flex; gap: 8px; align-items: center; } .iconBtn { height: 36px; min-width: 36px; padding: 0 10px; border: 1px solid #d1d5db; border-radius: 10px; background: #f3f4f6; /* единый фон как у "настройки" */ cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 8px; user-select: none; } .iconBtn:hover { background: #e5e7eb; } .iconBtn:active { transform: translateY(1px); } .iconBtnPrimary { border-color: #c7d2fe; background: #eef2ff; } .iconBtnPrimary:hover { background: #e0e7ff; } .main { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; } .page { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; padding: 12px; gap: 10px; } /* ===== Controls ===== */ .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; } .input { height: 34px; padding: 0 10px; border: 1px solid #d1d5db; border-radius: 10px; background: #fff; outline: none; } .input:focus { border-color: #a5b4fc; } .btn { height: 34px; padding: 0 12px; border: 1px solid #d1d5db; border-radius: 10px; background: #ffffff; cursor: pointer; } .btn:hover { background: #f9fafb; } .btn:active { transform: translateY(1px); } .badge { font-size: 12px; color: #374151; background: #f3f4f6; border: 1px solid #e5e7eb; border-radius: 999px; padding: 4px 10px; } /* ===== Table (virtualized grid) ===== */ .tableWrap { flex: 1 1 auto; min-height: 0; border: 1px solid #e5e7eb; border-radius: 12px; overflow: auto; position: relative; scrollbar-gutter: stable both-edges; background: #fff; } .tableInner { position: relative; min-width: 600px; } .headerRowSticky { position: sticky; top: 0; z-index: 5; background: #ffffff; border-bottom: 1px solid #e5e7eb; } .gridRow { display: grid; align-items: center; height: 34px; line-height: 34px; border-bottom: 1px solid #f3f4f6; } .headerCell { font-size: 12px; font-weight: 700; color: #374151; padding: 0 10px; position: relative; user-select: none; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .cell { font-size: 13px; padding: 0 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .rowAlt { background: #fcfcfd; } .resizeHandle { position: absolute; right: 0; top: 0; bottom: 0; width: 10px; cursor: col-resize; } .resizeGuide { position: absolute; top: 0; bottom: 0; width: 2px; background: #2563eb; opacity: 0.6; pointer-events: none; z-index: 10; } .dropGuide { position: absolute; top: 0; bottom: 0; width: 3px; background: #2563eb; opacity: 0.55; pointer-events: none; z-index: 9; } /* ===== Hidden columns bar (compact) ===== */ .hiddenBar { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; } .hiddenChip { height: 24px; padding: 0 8px; border: 1px dashed #d1d5db; border-radius: 999px; background: #ffffff; font-size: 12px; display: inline-flex; align-items: center; gap: 6px; } .hiddenChipBtn { border: none; background: #f3f4f6; border-radius: 999px; width: 18px; height: 18px; cursor: pointer; line-height: 18px; text-align: center; } .hiddenChipBtn:hover { background: #e5e7eb; } /* ===== Logs list ===== */ .logList { display: flex; flex-direction: column; gap: 8px; } .logItem { border: 1px solid #e5e7eb; border-radius: 12px; padding: 10px 12px; background: #fff; } .logTop { display: flex; justify-content: space-between; gap: 10px; align-items: baseline; } .logType { font-weight: 700; } .logMeta { color: #6b7280; font-size: 12px; } .logMsg { margin-top: 6px; color: #374151; font-size: 13px; white-space: pre-wrap; }
+
+/* ===== Sticky horizontal scrollbar (always visible) ===== */
+.hScrollSticky { position: sticky; bottom: 0; height: 14px; overflow-x: auto; overflow-y: hidden; background: #ffffff; border-top: 1px solid #e5e7eb; z-index: 6; }
+.hScrollStickyInner { height: 1px; }
