name: Windows CI (Озонатор)

on:
  push:
  pull_request:
  workflow_dispatch:
    inputs:
      run_e2e:
        description: 'Run optional E2E (Playwright Electron)'
        type: boolean
        default: false

jobs:
  windows-ci:
    runs-on: windows-latest

    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Prepare folders
        run: |
          New-Item -ItemType Directory -Force -Path logs, artifacts | Out-Null

      - name: Install dependencies (npm ci; fallback --legacy-peer-deps)
        id: install
        run: |
          $ok = $true

          try {
            npm ci *>&1 | Tee-Object -FilePath logs\install.log
            if ($LASTEXITCODE -ne 0) { throw "npm ci failed" }
          } catch {
            "npm ci failed. Retrying with npm ci --legacy-peer-deps" | Tee-Object -FilePath logs\install.log -Append
            npm ci --legacy-peer-deps *>&1 | Tee-Object -FilePath logs\install.log -Append
            if ($LASTEXITCODE -ne 0) { $ok = $false }
          }

          "ok=$($ok.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Lint
        id: lint
        if: always() && steps.install.outputs.ok == 'true'
        continue-on-error: true
        run: |
          npm run lint *>&1 | Tee-Object -FilePath logs\lint.log
          $ok = ($LASTEXITCODE -eq 0)
          "ok=$($ok.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Type check (script if exists; else tsc --noEmit)
        id: typecheck
        if: always() && steps.install.outputs.ok == 'true'
        continue-on-error: true
        run: |
          $pkg = Get-Content package.json -Raw | ConvertFrom-Json
          $hasTypecheck = $false
          if ($null -ne $pkg.scripts) {
            $hasTypecheck = $pkg.scripts.PSObject.Properties.Name -contains 'typecheck'
          }

          $status = 'skipped'
          $ok = $true

          if ($hasTypecheck) {
            npm run typecheck *>&1 | Tee-Object -FilePath logs\typecheck.log
            $ok = ($LASTEXITCODE -eq 0)
            $status = 'ran: npm run typecheck'
          } elseif (Test-Path -Path 'tsconfig.json') {
            npx tsc -p tsconfig.json --noEmit *>&1 | Tee-Object -FilePath logs\typecheck.log
            $ok = ($LASTEXITCODE -eq 0)
            $status = 'ran: npx tsc -p tsconfig.json --noEmit'
          } else {
            "No typecheck script and no tsconfig.json" | Tee-Object -FilePath logs\typecheck.log
            $ok = $true
            $status = 'skipped: no tsconfig/typecheck'
          }

          "ok=$($ok.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "status=$status" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Unit tests (npm test if exists)
        id: unit
        if: always() && steps.install.outputs.ok == 'true'
        continue-on-error: true
        run: |
          $pkg = Get-Content package.json -Raw | ConvertFrom-Json
          $hasTest = $false
          if ($null -ne $pkg.scripts) {
            $hasTest = $pkg.scripts.PSObject.Properties.Name -contains 'test'
          }

          $status = 'skipped'
          $ok = $true

          if ($hasTest) {
            npm test *>&1 | Tee-Object -FilePath logs\unit.log
            $ok = ($LASTEXITCODE -eq 0)
            $status = 'ran: npm test'
          } else {
            "No test script in package.json" | Tee-Object -FilePath logs\unit.log
            $ok = $true
            $status = 'skipped: no test script'
          }

          "ok=$($ok.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "status=$status" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Build installer (npm run dist)
        id: dist
        if: always() && steps.install.outputs.ok == 'true'
        continue-on-error: true
        run: |
          npm run dist -- --publish never *>&1 | Tee-Object -FilePath logs\dist.log
          $ok = ($LASTEXITCODE -eq 0)
          "ok=$($ok.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Collect artifacts (installer + portable)
        id: collect
        if: always() && steps.install.outputs.ok == 'true'
        continue-on-error: true
        run: |
          $installerOk = $false
          $portableOk = $false

          # 1) Installer: prefer already-renamed root artifact if project uses build.artifactName "../Озонатор.${ext}"
          $rootExe = Join-Path $PWD 'Озонатор.exe'
          if (Test-Path $rootExe) {
            Copy-Item $rootExe -Destination 'artifacts\Озонатор.exe' -Force
            $installerOk = $true
          } else {
            # Find Setup*.exe in release\**
            if (Test-Path 'release') {
              $setup = Get-ChildItem -Path 'release' -Recurse -File -Filter '*.exe' |
                Where-Object { $_.Name -match '(?i)setup' } |
                Sort-Object LastWriteTime -Descending |
                Select-Object -First 1

              if ($null -ne $setup) {
                Copy-Item $setup.FullName -Destination 'artifacts\Озонатор.exe' -Force
                $installerOk = $true
              }
            }
          }

          # 2) Portable: zip win-unpacked
          $winUnpacked = $null
          if (Test-Path 'release') {
            $winUnpacked = Get-ChildItem -Path 'release' -Directory -Recurse |
              Where-Object { $_.Name -eq 'win-unpacked' } |
              Select-Object -First 1
          }

          if ($null -ne $winUnpacked) {
            $zipPath = Join-Path $PWD 'artifacts\portable-win-unpacked.zip'
            if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
            Compress-Archive -Path (Join-Path $winUnpacked.FullName '*') -DestinationPath $zipPath
            $portableOk = $true
          }

          "installer_ok=$($installerOk.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "portable_ok=$($portableOk.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Optional E2E (Playwright Electron)
        id: e2e
        if: always() && steps.install.outputs.ok == 'true' && github.event_name == 'workflow_dispatch' && inputs.run_e2e
        continue-on-error: true
        run: |
          # E2E is stage 2: run only if repo already contains Playwright config + tests.
          $hasCfg = Test-Path 'playwright.config.ts'
          $hasTests = Test-Path 'tests\e2e'

          if (-not $hasCfg -or -not $hasTests) {
            "E2E skipped: playwright.config.ts and/or tests\\e2e are not present in repo" | Tee-Object -FilePath logs\e2e.log
            "ok=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "status=skipped" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          npx playwright install --with-deps *>&1 | Tee-Object -FilePath logs\e2e.log
          if ($LASTEXITCODE -ne 0) {
            "ok=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "status=failed: playwright install" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          npx playwright test *>&1 | Tee-Object -FilePath logs\e2e.log -Append
          $ok = ($LASTEXITCODE -eq 0)
          "ok=$($ok.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "status=ran" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Generate TestReport.txt (118 matrix)
        if: always()
        run: |
          function StatusLine($n, $name, $status, $why) {
            if ($status -eq 'PASS') { return ("{0}. {1} — PASS" -f $n.ToString().PadLeft(3,' '), $name) }
            if ($status -eq 'FAIL') { return ("{0}. {1} — FAIL ({2})" -f $n.ToString().PadLeft(3,' '), $name, $why) }
            return ("{0}. {1} — НЕ ВЫПОЛНЯЛОСЬ ({2})" -f $n.ToString().PadLeft(3,' '), $name, $why)
          }

          $tests = @(
            @{n=1; name='Статическое тестирование (Static testing)'},
            @{n=2; name='Ревью требований (Requirements review)'},
            @{n=3; name='Ревью архитектуры/логики ответа (Architecture review)'},
            @{n=4; name='Ревью дизайна формата ответа (Design review)'},
            @{n=5; name='Ревью промпта (Code review)'},
            @{n=6; name='Статический анализ (Static analysis)'},
            @{n=7; name='Линтинг (Linter)'},
            @{n=8; name='Проверка схемы/типов результата (Type checking)'},
            @{n=9; name='Модульное (Unit)'},
            @{n=10; name='Компонентное (Component)'},
            @{n=11; name='Интеграционное (Integration)'},
            @{n=12; name='Системное (System)'},
            @{n=13; name='Сквозное (End-to-end)'},
            @{n=14; name='Приёмочное (Acceptance, UAT — user acceptance testing)'},
            @{n=15; name='Функциональное (Functional)'},
            @{n=16; name='Нефункциональное (Non-functional)'},
            @{n=17; name='Тестирование пользовательского интерфейса (UI testing)'},
            @{n=18; name='Контракт ответа (API testing)'},
            @{n=19; name='Визуальная регрессия форматирования (Visual regression)'},
            @{n=20; name='Работа с табличными правилами/структурами (Database testing)'},
            @{n=21; name='Очереди/события взаимодействия (Queue/Event testing)'},
            @{n=22; name='Интеграции со сторонними источниками/правилами (Third-party integration)'},
            @{n=23; name='Смоук (Smoke)'},
            @{n=24; name='Санити (Sanity)'},
            @{n=25; name='Регресс (Regression)'},
            @{n=26; name='Релиз-кандидат (Release candidate)'},
            @{n=27; name='Альфа (Alpha)'},
            @{n=28; name='Бета (Beta)'},
            @{n=29; name='Догфудинг (Dogfooding)'},
            @{n=30; name='Полевое (Field)'},
            @{n=31; name='Ручное (Manual)'},
            @{n=32; name='Автоматизированное (Automated)'},
            @{n=33; name='Скриптовое (Scripted)'},
            @{n=34; name='Исследовательское (Exploratory)'},
            @{n=35; name='Чёрный ящик (Black-box)'},
            @{n=36; name='Белый ящик (White-box)'},
            @{n=37; name='Серый ящик (Gray-box)'},
            @{n=38; name='Производительность (Performance)'},
            @{n=39; name='Нагрузка (Load)'},
            @{n=40; name='Стресс (Stress)'},
            @{n=41; name='Длительное (Soak/Endurance)'},
            @{n=42; name='Масштабируемость (Scalability)'},
            @{n=43; name='Ресурсы (Resource usage)'},
            @{n=44; name='Отзывчивость (Responsiveness)'},
            @{n=45; name='Надёжность (Reliability)'},
            @{n=46; name='Устойчивость к сбоям (Resilience)'},
            @{n=47; name='Переключение при отказе (Failover)'},
            @{n=48; name='Восстановление (Recovery)'},
            @{n=49; name='Откат (Rollback)'},
            @{n=50; name='Учения восстановления (Disaster recovery drills)'},
            @{n=51; name='Деградация (Degradation)'},
            @{n=52; name='Плохая сеть/ограничения (Network)'},
            @{n=53; name='Безопасность (Security)'},
            @{n=54; name='Пентест/инъекции (Penetration)'},
            @{n=55; name='Красная команда (Red teaming)'},
            @{n=56; name='Статический анализ безопасности приложения (SAST — static application security testing)'},
            @{n=57; name='Динамический анализ безопасности приложения (DAST — dynamic application security testing)'},
            @{n=58; name='Анализ состава программных компонентов (SCA — software composition analysis)'},
            @{n=59; name='Фаззинг (Fuzz)'},
            @{n=60; name='Контроль цепочки результата/политик (Software supply chain testing)'},
            @{n=61; name='Контрактное (Contract)'},
            @{n=62; name='Контракт, управляемый потребителем (Consumer-driven contract)'},
            @{n=63; name='Снапшоты (Snapshot)'},
            @{n=64; name='Эталонный снимок результата (Golden master)'},
            @{n=65; name='Дифференциальное (Differential)'},
            @{n=66; name='Метаморфное (Metamorphic)'},
            @{n=67; name='Свойственно-ориентированное тестирование (Property-based)'},
            @{n=68; name='Мутационное (Mutation)'},
            @{n=69; name='Модельно-ориентированное тестирование (Model-based)'},
            @{n=70; name='Комбинаторное тестирование (Combinatorial/Pairwise)'},
            @{n=71; name='Обезьянье тестирование (Monkey)'},
            @{n=72; name='Конкурентность (Concurrency)'},
            @{n=73; name='Гонки/дедлоки (Race/Deadlock)'},
            @{n=74; name='Идемпотентность (Idempotency)'},
            @{n=75; name='Повторы (Retry)'},
            @{n=76; name='Дедупликация (Deduplication)'},
            @{n=77; name='Семантика доставки (At-least-once/Exactly-once)'},
            @{n=78; name='Согласованность (Consistency)'},
            @{n=79; name='Многорегиональность (Multi-region)'},
            @{n=80; name='Изоляция контекста/ролей (Isolation/Multi-tenant)'},
            @{n=81; name='Запись и воспроизведение (Record & Replay)'},
            @{n=82; name='Теневая проверка (Shadow)'},
            @{n=83; name='Скрытый запуск (Dark launch)'},
            @{n=84; name='Канареечный анализ (Canary analysis)'},
            @{n=85; name='Синтетический мониторинг (Synthetic monitoring)'},
            @{n=86; name='Тест «А/А» (A/A)'},
            @{n=87; name='Наблюдаемость (Observability)'},
            @{n=88; name='Логирование (Logging)'},
            @{n=89; name='Метрики (Metrics)'},
            @{n=90; name='Трассировка (Tracing)'},
            @{n=91; name='Оповещения (Alerting)'},
            @{n=92; name='Схема телеметрии (Telemetry schema)'},
            @{n=93; name='События аналитики (Analytics events)'},
            @{n=94; name='Качество данных (Data quality)'},
            @{n=95; name='Конвейер данных (ETL/Pipeline)'},
            @{n=96; name='Большие данные (Large data/Big data)'},
            @{n=97; name='Совместимость (Compatibility)'},
            @{n=98; name='Локализация (Localization)'},
            @{n=99; name='Доступность (Accessibility)'},
            @{n=100; name='Удобство использования (Usability)'},
            @{n=101; name='Обновление (Upgrade)'},
            @{n=102; name='Миграция и миграция схемы (Migration/Schema migration)'},
            @{n=103; name='Конфигурация (Configuration)'},
            @{n=104; name='Дрейф конфигурации (Configuration drift)'},
            @{n=105; name='Функциональные флаги (Feature flags)'},
            @{n=106; name='Обратная совместимость (Backward compatibility)'},
            @{n=107; name='Прямая совместимость (Forward compatibility)'},
            @{n=108; name='Ограничение запросов и квоты (Rate limiting/Quota)'},
            @{n=109; name='Защита от злоупотреблений и антифрод (Abuse/Anti-fraud)'},
            @{n=110; name='Защита от ботов (Bot mitigation)'},
            @{n=111; name='Биллинг и измерение потребления (Billing/Metering)'},
            @{n=112; name='Журнал аудита (Audit trail)'},
            @{n=113; name='Неизменяемость (Immutability)'},
            @{n=114; name='Срок хранения и право на удаление (Retention/Right to erasure)'},
            @{n=115; name='Хаос-тестирование (Chaos)'},
            @{n=116; name='Сертификация и регуляторика (Certification/Regulatory)'},
            @{n=117; name='Формальная верификация (Formal verification)'},
            @{n=118; name='Настольные учения (Tabletop exercises)'}
          )

          # Map CI steps to test statuses
          $installOk = '${{ steps.install.outputs.ok }}'
          $lintOk = '${{ steps.lint.outputs.ok }}'
          $typeOk = '${{ steps.typecheck.outputs.ok }}'
          $unitOk = '${{ steps.unit.outputs.ok }}'
          $distOk = '${{ steps.dist.outputs.ok }}'
          $installerOk = '${{ steps.collect.outputs.installer_ok }}'
          $portableOk = '${{ steps.collect.outputs.portable_ok }}'
          $e2eRan = '${{ github.event_name == 'workflow_dispatch' && inputs.run_e2e }}'
          $e2eOk = '${{ steps.e2e.outputs.ok }}'
          $typeStatus = '${{ steps.typecheck.outputs.status }}'
          $unitStatus = '${{ steps.unit.outputs.status }}'

          # Default: NOT RUN
          $statusMap = @{}
          foreach ($t in $tests) { $statusMap[$t.n] = @{ status='NR'; why='требует ручной проверки/не настроено в CI (этап 1)' } }

          # What we can honestly mark as PASS/FAIL in stage 1
          if ($lintOk -ne '') { $statusMap[6] = @{ status=($lintOk -eq 'true' ? 'PASS' : 'FAIL'); why='см. logs\\lint.log' } }
          if ($lintOk -ne '') { $statusMap[7] = @{ status=($lintOk -eq 'true' ? 'PASS' : 'FAIL'); why='см. logs\\lint.log' } }
          if ($typeOk -ne '') { $statusMap[8] = @{ status=($typeOk -eq 'true' ? 'PASS' : 'FAIL'); why="$typeStatus; см. logs\\typecheck.log" } }
          if ($unitOk -ne '') { $statusMap[9] = @{ status=($unitOk -eq 'true' ? 'PASS' : 'FAIL'); why="$unitStatus; см. logs\\unit.log" } }

          if ($distOk -ne '') { $statusMap[26] = @{ status=($distOk -eq 'true' ? 'PASS' : 'FAIL'); why='см. logs\\dist.log' } }

          # Artifacts generation check (maps to Smoke/Sanity in CI context)
          if ($installerOk -eq 'true' -and $portableOk -eq 'true') {
            $statusMap[23] = @{ status='PASS'; why='' }
            $statusMap[24] = @{ status='PASS'; why='' }
          } else {
            $statusMap[23] = @{ status='FAIL'; why='артефакты не собраны полностью (installer/portable) — см. job logs' }
            $statusMap[24] = @{ status='FAIL'; why='артефакты не собраны полностью (installer/portable) — см. job logs' }
          }

          # Optional E2E stage 2
          if ($e2eRan -eq 'true') {
            if ($e2eOk -eq 'true') {
              $statusMap[13] = @{ status='PASS'; why='см. logs\\e2e.log и playwright-report (если включён)'}
              $statusMap[14] = @{ status='PASS'; why='см. logs\\e2e.log и скриншоты (если настроены)'}
            } else {
              $statusMap[13] = @{ status='FAIL'; why='см. logs\\e2e.log'}
              $statusMap[14] = @{ status='FAIL'; why='см. logs\\e2e.log'}
            }
          } else {
            $statusMap[13] = @{ status='NR'; why='E2E для Electron (Playwright) не включён в этапе 1' }
            $statusMap[14] = @{ status='NR'; why='UAT требует реального пользователя; автопрогон будет в этапе 2' }
          }

          $lines = New-Object System.Collections.Generic.List[string]
          $lines.Add('TestReport — Windows CI (GitHub Actions)')
          $lines.Add(('Run: {0}' -f $env:GITHUB_RUN_ID))
          $lines.Add(('Commit: {0}' -f $env:GITHUB_SHA))
          $lines.Add(('Workflow: {0}' -f $env:GITHUB_WORKFLOW))
          $lines.Add(('Job: {0}' -f $env:GITHUB_JOB))
          $lines.Add('')
          $lines.Add('Логи:')
          $lines.Add(' - logs\\install.log')
          $lines.Add(' - logs\\lint.log')
          $lines.Add(' - logs\\typecheck.log')
          $lines.Add(' - logs\\unit.log')
          $lines.Add(' - logs\\dist.log')
          $lines.Add(' - logs\\e2e.log (если запускался)')
          $lines.Add('')
          $lines.Add('Артефакты (ожидаемые):')
          $lines.Add(' - artifacts\\Озонатор.exe')
          $lines.Add(' - artifacts\\portable-win-unpacked.zip')
          $lines.Add(' - artifacts\\TestReport.txt')
          $lines.Add('')

          $executedCount = 0
          $failList = New-Object System.Collections.Generic.List[string]

          foreach ($t in $tests) {
            $st = $statusMap[$t.n]
            if ($st.status -ne 'NR') { $executedCount += 1 }
            if ($st.status -eq 'FAIL') { $failList.Add([string]$t.n) }
          }

          $notRunCount = 118 - $executedCount
          $cycles = 1

          # Summarize why not all 118
          $why = 'CI автоматизирует только часть матрицы (этап 1: lint/typecheck/unit/dist + сбор артефактов). Остальные пункты требуют ручной UX-оценки, реального пользователя, окружения/инфраструктуры, либо будут автоматизированы в этапе 2 (E2E Playwright Electron).'
          $lines.Insert(0, ("{0} из 118, {1} цикл(а/ов). {2} тестов не выполнялись, так как {3}" -f $executedCount, $cycles, $notRunCount, $why))
          $lines.Insert(1, '')
          $lines.Add('')
          $lines.Add('Матрица 118 (статус по каждому пункту):')

          if ($failList.Count -gt 0) {
            $lines.Add(('Провалены тесты: ' + ($failList -join ', ')))
          } else {
            $lines.Add('Проваленных тестов: нет')
          }
          $lines.Add('')


          foreach ($t in $tests) {
            $st = $statusMap[$t.n]
            if ($st.status -eq 'PASS') {
              $lines.Add((StatusLine $t.n $t.name 'PASS' ''))
            } elseif ($st.status -eq 'FAIL') {
              $lines.Add((StatusLine $t.n $t.name 'FAIL' $st.why))
            } else {
              $lines.Add((StatusLine $t.n $t.name 'NR' $st.why))
            }
          }

          $out = Join-Path $PWD 'artifacts\TestReport.txt'
          $lines | Out-File -FilePath $out -Encoding UTF8

      - name: Upload artifact — Озонатор.exe
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: Озонатор.exe
          path: artifacts/Озонатор.exe
          if-no-files-found: warn

      - name: Upload artifact — portable-win-unpacked.zip
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: portable-win-unpacked.zip
          path: artifacts/portable-win-unpacked.zip
          if-no-files-found: warn

      - name: Upload artifact — TestReport.txt
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: TestReport.txt
          path: artifacts/TestReport.txt
          if-no-files-found: warn

      - name: Upload artifact — build-logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: logs/**



      - name: Upload artifact — e2e-results
        if: always() && github.event_name == 'workflow_dispatch' && inputs.run_e2e
        uses: actions/upload-artifact@v4
        with:
          name: e2e-results
          path: |
            playwright-report/**
            test-results/**
          if-no-files-found: warn

      - name: Final gate (fail job if CI checks failed)
        if: always() && steps.install.outputs.ok == 'true'
        run: |
          $failed = @()

          if ('${{ steps.lint.outputs.ok }}' -eq 'false') { $failed += 'lint' }
          if ('${{ steps.typecheck.outputs.ok }}' -eq 'false') { $failed += 'typecheck' }
          if ('${{ steps.unit.outputs.ok }}' -eq 'false') { $failed += 'unit' }
          if ('${{ steps.dist.outputs.ok }}' -eq 'false') { $failed += 'dist' }
          if ('${{ steps.collect.outputs.installer_ok }}' -ne 'true') { $failed += 'installer artifact' }
          if ('${{ steps.collect.outputs.portable_ok }}' -ne 'true') { $failed += 'portable artifact' }

          if ($failed.Count -gt 0) {
            Write-Error ("CI failed checks: {0}. See TestReport.txt + build-logs." -f ($failed -join ', '))
          } else {
            Write-Host 'CI checks passed.'
          }
